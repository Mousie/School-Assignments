/*
 * Lab06.c
 *
 * Created: 10/24/2020 12:02:28 PM
 * Author : Christopher Kihano
 * RedID: 824744811
 *
 * For this lab assignment, you must use interrupts and PWM output generated by
 * timers. 
 *
 * This is the first lab of the course to introduce interrupts to you, and it 
 * intends to use different kinds of interrupts to do various things:
 * - Use a pin change interrupt to toggle the LED
 * - Use a timer interrupt to scan a key pad periodically, and then generate a 
 *   duty cycle waveform based on which button is pushed (calculate the 
 *   percentage of the duty cycle)
 *
 * You should use your code from Lab-04 to scan a keypad but keypad scan should
 * occur in an ISR. Also, you should set the OCRnB value to the equivalent 
 * percent of the OCRnA value (n:0, 1, or 2 depending on the timer you use) 
 * depending on which key is pressed.
 *
 * Here are the detailed functions, which will help you output a pulse with the
 * following characteristics:
 * 1. Set up a timer to generate an interrupt every (X+1) ms -- the timer ISR 
 *    scans the keypad and toggles a GPIO pin
 * 2. Set up the ISR above to save 0 to 9 based on the button 0-9 on the 
 *    keypad, and save 0-9 value in a global short integer variable
 * 3. In the main() loop, using the keypad input, set another timer to generate
 *    a duty cycle waveform on LED (this changes the LED brightness – remember 
 *    Lab-05), based on the keypad input from 0-90%. The duty cycle frequency 
 *    should be (Z+1)*100 Hz
 *
 * The X and Z values above are based on the last three digits of your Red ID 
 * number as follows:
 * • Use the last 3 digits of your Red ID as in 812345XYZ
 * • The timer Interrupt period should be (X+1) ms
 * • The duty cycle should be based on the key pressed: button 0=off, 1=10%, 
 *   2=20%, ... 9=90% duty cycle.
 * • PWM Frequency is (Z+1)*100 Hz
 *
 * Final demonstration will include the duty cycle (DC) generated with values 
 * corresponding to the number pressed on the keypad (i.e. 0 = 0% DC, 1 = 10%
 * DC …, 9 = 90% DC).
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>

uint8_t const length[4][4] PROGMEM = {
	{ 7, 15, 23, 0},
	{30, 38, 46, 0},
	{53, 61, 69, 0},
	{ 0,  0,  0, 0}
};

// Detect a button has been pressed on port D.
ISR(PCINT2_vect){
	uint8_t pos1, pos2;
	// Lower 4 bits are inputs
	// Upper 4 bits are outputs
	int input = PIND;
	if((input & 0x0F) != 0x0F){
		for(int i = 0; i < 4; i++){
			if(!(input & 0x01))
				pos1 = i;
			if(!(input & 0x10))
				pos2 = i;
			input >>= 1;
		}
		OCR0B = pgm_read_byte(&(length[pos1][pos2]));
	}
	
}

// Turn LED ON
ISR(TIMER0_COMPA_vect){
	if(OCR0B != 0)
		PORTB |= (1 << PORTB5);
}

// Turn LED OFF
ISR(TIMER0_COMPB_vect){
	PORTB &= ~(1 << PORTB5);
}

// Cycle through keypad outputs
ISR(TIMER2_COMPA_vect){
	static uint8_t pin;
	PORTD = (~(1 << 4 + (pin++ & 0b11)) & 0xF0) | (PORTD & 0x0F);
}

void keypad_init(){
	// Set outputs
	DDRD |= (1 << DDRD4) | (1 << DDRD5) | (1 << DDRD6) | (1 << DDRD7);
	// Set all outputs as high
	PORTD |= (1 << PORTD4) | (1 << PORTD5) | (1 << PORTD6) | (1 << PORTD7);
	// Set inputs
	DDRD &= ~((1 << DDRD0) | (1 << DDRD1) | (1 << DDRD2) | (1 << DDRD3));
	// Enable pullup resistors
	PORTD |= (1 << PORTD0) | (1 << PORTD1) | (1 << PORTD2) | (1 << PORTD3);
	// Enable interrupts on PORTD
	PCICR |= (1 << PCIE2);
	// Enable interrupts on Pins D0-D3
	PCMSK2 |= (1 << PCINT16) | (1 << PCINT17) | (1 << PCINT18) | (1 << PCINT19);
	return;
}

void timer_init(){
	// LED Timer
	// Set TIMER0 to use CTC mode and pre-scalar of 1024
	// RedID is 824744811 so the "Z" digit would be a 1, (1+1)*100 Hz=200 Hz
	// To find the amount of time for this frequency, it's 1/Hz or 1/200=0.005
	// Plugging this into our equation for CTC timers,
	// (F_clk/N)*T-1 where F_clk = 16000000, N = prescaler of 1024, T = 0.005
	// The above equation gives me a value of 77.125, truncated to 77.
	// For my % values, I'm doing 77.125/10 = 7.7125 for each step and
	// truncating the result. So step 1 = 7, step 2 = 15, step 3 = 23, ....
	TCCR0A |= (1 << WGM01);
	TCCR0B |= (1 << CS02) | (1 << CS00);
	OCR0A = 77;
	TIMSK0 |= (1 << OCIE0A) | (1 << OCIE0B);
	
	// Keypad Timer
	// Set TIMER2 to use CTC mode and pre-scaler of 1024
	// RedID is 824744811 so the "X" digit would be an 8, 1ms + 8 ms = 9 ms
	// (F_clk/N)*T-1 where F_clk = 16000000, N = prescaler of 1024, T = 0.009
	// The above equation gives me a value of 139.625, truncated to 139.
	TCCR2A |= (1 << WGM21);
	TCCR2B |= (1 << CS22) | (1 << CS21) | (1 << CS20);
	
	OCR2A = 139;
	// Timer Interrupt Mask Register
	TIMSK2 |= (1 << OCIE2A);
}

int main(void)
{
	// LED to output
	DDRB |= (1 << DDRB5);
	keypad_init();
	timer_init();
	sei();
    while (1) {}
}

